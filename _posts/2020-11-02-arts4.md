---
layout: post
title: 前端ARTS打卡计划（四）
categories: ARTS
description: 前端ARTS打卡计划。
keywords: ARTS, 前端, leetCode
---

&emsp;&emsp;前端 ARTS 打卡计划（四）。

## ARTS 打卡计划

### 第三十一周(2020.11.02-2020.11.08)

- Algorithm：

  - [485. 最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/submissions/){:target='_blank'}
  - [595. 大的国家](https://leetcode-cn.com/problems/big-countries/){:target='_blank'}
  - [627. 变更性别](https://leetcode-cn.com/problems/swap-salary/){:target='_blank'}
    ```sql
    # 给定一个 salary 表，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。
      UPDATE salary
        SET
          sex = CASE sex
              WHEN 'm' THEN 'f'
              ELSE 'm'
            END;
    ```
    
    > [SQL之CASE WHEN用法详解](https://blog.csdn.net/rongtaoup/article/details/82183743){:target='_blank'}

- Review:

- Tip：

  - [Web Components 入门实例教程-阮一峰](http://www.ruanyifeng.com/blog/2019/08/web_components.html){:target='_blank'}：
    - 浏览器可以识别不规则、不合法标签（元素）；
    - 自定义继承自`HTMLElement`的类，称为自定义元素的类；
    - 经过`window.customElements.define`API使得**不合法标签**（自定义元素）与自定义元素的类关联，实现**合法化**；
    - 通过模板标签`<template>`简化类的定义过程并添加样式；
    - 通过自定义元素的`attachShadow()`方法开启 Shadow DOM（这部分 DOM 默认与外部 DOM 隔离，内部任何代码都无法影响外部），隐藏自定义元素的内部实现；
    - 添加事件监听、进行组件化封装等。

  - `Element.getBoundingClientRect()`：返回元素的大小及其相对于视口的位置。
    > [getBoundingClientRect 方法](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect){:target='_blank'}用来描述一个元素的具体位置，该位置的下面四个属性都是相对于视口左上角的位置而言的。对某一节点执行该方法，它的返回值是一个 DOMRect 类型的对象。这个对象表示一个矩形盒子，它含有：left、top、right 和 bottom 等只读属性。

    ![getBoundingClientRect]({{site.url}}{{site.baseurl}}/images/posts/arts/rect.png?raw=true)

  - 数组 reduce 方法的相关实现

    - reduce 的实现
    ```js
      Array.prototype.customReduce = Array.prototype.reduce || function(callback, initialValue) {
          // 简单异常处理
          if (this === null) {
            throw new TypeError( 'Array.prototype.customReduce ' + 
              'called on null or undefined' )
          }
          if (typeof callback !== 'function') {
            throw new TypeError( callback +
              ' is not a function')
          }
          // 核心实现
          let result = typeof initialValue === 'undefined' ? this[0] : initialValue
          var startIndex = typeof initialValue === 'undefined' ? 1 : 0
          this.slice(startIndex)
              .forEach(function(val, index) {
                  result = callback(result, val, index + startIndex, this)
              })
          return result
      };
      [1,2,3,5,8].customReduce((pre, cur) => pre + cur); // 19
      [1,2,3,5,8].customReduce((pre, cur) => pre + cur, 3); // 22
    ```
      > 这里使用了forEach，不想使用forEach或因兼容性考虑，可参考我之前的一篇文章[JavaScript很简单？那你理解的forEach真的对吗？](https://king-hcj.github.io/2020/10/03/you-dont-know-foreach/){:target='_blank'} ，自己实现forEach，替换掉相关代码。

    - 按顺序运行 Promise
    ```js
      // runPromiseInSequence 方法将会被一个每一项都返回一个 Promise 的数组调用，并且依次执行数组中的每一个 Promise
      const runPromiseInSequence = (array, value) => array.reduce(
        (promiseChain, currentFunction) => promiseChain.then(currentFunction),
        Promise.resolve(value)
      )
    ```

    - 函数式方法 pipe 的实现
    ```js
    // pipe(f, g, h) 是一个 curry 化函数，它返回一个新的函数，这个新的函数将会完成 (...args) => h(g(f(...args))) 的调用。即 pipe 方法返回的函数会接收一个参数，这个参数传递给 pipe 方法第一个参数，以供其调用。
    const pipe = (...functions) => input => functions.reduce(
        (acc, fn) => fn(acc),
        input
    )
    ```

    -  Koa only 模块实现（Lodash的Pick、omit方法同理）
    ```js
    const only = function(obj, keys){
        obj = obj || {}
        if ('string' == typeof keys) keys = keys.split(/ +/)
        return keys.reduce(function(ret, key) {
            if (null == obj[key]) return ret
            ret[key] = obj[key]
            return ret
        }, {})
    };
    const o = {
        a: 'a',
        b: 'b',
        c: 'c'
    }
    only(o, ['a','b'])   // {a: 'a',  b: 'b'}
    ```

    - 告别繁琐的环境变量设置：[Windows使用cmd命令行查看、修改、删除与添加环境变量](https://www.cnblogs.com/springsnow/p/12610417.html){:target='_blank'}
      ```s
      # 查看当前所有可用的环境变量
      set
      # 查看某个环境变量：查看path变量的值
      set path
      # 修改环境变量（注意：这里是覆盖）
      set 变量名=变量内容
      # 设置为空
      set 变量名=
      # 给变量追加内容（%变量名%;代表以前的值）
      set 变量名=%变量名%;变量内容
      # 将C:\Go\bin\添加到path中
      set path=%path%;C:\Go\bin\
      ```

- Share：

  - [我们不背诵 API，只实现 API](https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5c99c8d6ccb24267c1d01dab){:target='_blank'}
  - [终于有人把Elasticsearch原理讲透了！](https://zhuanlan.zhihu.com/p/62892586){:target='_blank'}
  - [知乎-Elasticsearch](https://www.zhihu.com/search?q=elasticsearch&type=content){:target='_blank'}

### 第三十二周(2020.11.09-2020.11.15)

- Algorithm：

- Review: 

- Tip：

  - [AntD Table：对于长表格，需要滚动才能查看表头和滚动条，那么现在可以设置跟随页面固定表头和滚动条](https://ant.design/components/table-cn/#components-table-demo-sticky){:target='_blank'}（4.6.0版本开始支持）
  - [关于表格内编辑，优化方法！](https://github.com/ant-design/ant-design/issues/2884){:target='_blank'}
  - 常用`git stash`命令：
    1. `git stash save "save message"`：执行存储时，添加备注，方便查找，只有`git stash` 也可以，但查找时不方便识别；
    2. `git stash list`：查看stash了哪些存储；
    3. `git stash show`：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加`stash@{$num}`，比如第二个 `git stash show stash@{1}`；
    4. `git stash show -p `：显示第一个存储的改动，如果想显示其他存储，命令：`git stash show  stash@{$num}  -p` ，比如第二个：`git stash show  stash@{1}  -p`；
    5. `git stash apply`：应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即`stash@{0}`，如果要使用其他个，`git stash apply stash@{$num}`， 比如第二个：`git stash apply stash@{1}`；
    6. `git stash pop`：恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即`stash@{0}`，如果要应用并删除其他stash，命令：`git stash pop stash@{$num}`，比如应用并删除第二个：`git stash pop stash@{1}`；
    7. `git stash drop stash@{$num}`：丢弃`stash@{$num}`存储，从列表中删除这个存储；
    8. `git stash clear`：删除所有缓存的stash。

- Share：

  - [小蝌蚪传记：让接口提速60%的优化技巧](https://segmentfault.com/a/1190000037780624){:target='_blank'}（**代理层对接口数据进行了一次过滤，减少了http传输时延；引入redis，减少了不必要的溯源。**）
  - [JavaScript 20 年](https://cn.history.js.org/){:target='_blank'}


